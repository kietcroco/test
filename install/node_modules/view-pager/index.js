"use strict";

import PropTypes from 'prop-types';

import React from 'react';
import {
	View,
	ListView,
	Platform
} from 'react-native';

import Scroller from 'scroller';
import { createResponder } from 'gesture-responder';
import shallowEqual from 'fbjs/lib/shallowEqual';

const MIN_FLING_VELOCITY = 0.5;

class ViewPager extends React.Component {

	static displayName = "ViewPager";

	static propTypes = {
		initialPage: PropTypes.number,
		pageMargin: PropTypes.number,
		scrollEnabled: PropTypes.bool,
		renderPage: PropTypes.func,
		pageDatas: PropTypes.array,
		onPageSelected: PropTypes.func,
		onPageScrollStateChanged: PropTypes.func,
		onPageScroll: PropTypes.func,

		onSingleTap: PropTypes.func,
		onDoubleTap: PropTypes.func,
		onTouchStart: PropTypes.func,
		onTouchMove: PropTypes.func,
		onTouchEnd: PropTypes.func,
		onTouchCancel: PropTypes.func,
		onPageScrollMoved: PropTypes.func
	};

	static defaultProps = {
		initialPage: 0,
		pageMargin: 0,
		scrollEnabled: true,
		pageDatas: []
	};

	constructor(props) {
		super(props);

		this.pageCount = props.pageDatas.length; //Initialize to avoid undefined error
		this.currentPage = this.validPage( props.initialPage ); //Do not initialize to make onPageSelected(0) be dispatched
		this.layoutChanged = false;
		this.initialPageSettled = false;
		this.activeGesture = false;
		this.gestureResponder = undefined;

		const ds = new ListView.DataSource({ rowHasChanged: (r1, r2) => r1 !== r2 });
		this.state = {
			width: 0,
			height: 0,
			dataSource: ds.cloneWithRows([])
		};

		this.scroller = new Scroller(true, (dx, dy, scroller) => {

			if (dx === 0 && dy === 0 && scroller.isFinished()) {

				if (!this.activeGesture) {

					this.onPageScrollStateChanged('idle');
				}
			} else {

				const curX = this.scroller.getCurrX();
				this.listView.scrollTo({ x: curX, animated: false });

				let position = Math.floor(curX / (this.state.width + this.props.pageMargin));
				position = this.validPage(position);

				let offset = (curX - this.getScrollOffsetOfPage(position)) / (this.state.width + this.props.pageMargin);
				let fraction = (curX - this.getScrollOffsetOfPage(position) - this.props.pageMargin) / this.state.width;
				if (fraction < 0) {
					fraction = 0;
				}

				this.props.onPageScroll && this.props.onPageScroll({
					position, 
					offset, 
					fraction
				});
			}
		});
	}

	componentWillReceiveProps(nextProps) {

		if( this.props.pageDatas != nextProps.pageDatas ) {

			this.setState({
				dataSource: this.state.dataSource.cloneWithRows( nextProps.pageDatas )
			});

			this.pageCount = nextProps.pageDatas.length;
			let currentPage = this.validPage( this.currentPage );
			if( currentPage !== this.currentPage ) {

				this.setPage( currentPage );
			}
		}

		if( this.props.initialPage !== nextProps.initialPage ) {

			this.setPage( nextProps.initialPage );
		}
	}

	componentWillMount() {

		this.gestureResponder = createResponder({
			onStartShouldSetResponder: () => true,
			onResponderGrant: this.onResponderGrant.bind(this),
			onResponderMove: this.onResponderMove.bind(this),
			onResponderRelease: this.onResponderRelease.bind(this),
			onResponderTerminate: this.onResponderRelease.bind(this),
			onResponderReject: this.onResponderReject.bind(this),
			onResponderSingleTapConfirmed: this.onResponderSingleTapConfirmed.bind(this),
			onResponderDoubleTapConfirmed: this.onResponderDoubleTapConfirmed.bind(this)
		});
	}

	shouldComponentUpdate( nextProps, nextState ) {

		return (
			this.state.width !== nextState.width ||
			this.state.height !== nextState.height ||
			this.state.dataSource !== nextState.dataSource ||
			!shallowEqual( this.props, nextProps )
		);
	}

	onResponderGrant(evt, gestureState) {

		this.props.onTouchStart && this.props.onTouchStart(evt, gestureState);
		this.scroller.forceFinished(true);
		this.activeGesture = true;
		this.onPageScrollStateChanged('dragging');
	}

	onResponderSingleTapConfirmed(evt, gestureState) {

		this.props.onSingleTap && this.props.onSingleTap(evt, gestureState, {
			currentPage: this.currentPage,
			totalPage: this.pageCount,
			width: this.state.width,
			height: this.state.height,
			pageData: this.props.pageDatas[ this.currentPage ]
		});
	}

	onResponderDoubleTapConfirmed(evt, gestureState) {

		this.props.onDoubleTap && this.props.onDoubleTap(evt, gestureState, {
			currentPage: this.currentPage,
			totalPage: this.pageCount,
			width: this.state.width,
			height: this.state.height,
			pageData: this.props.pageDatas[ this.currentPage ]
		});
	}

	onResponderReject(evt, gestureState) {

		this.props.onTouchCancel && this.props.onTouchCancel(evt, gestureState);
	}

	onResponderMove(evt, gestureState) {

		this.props.onTouchMove && this.props.onTouchMove( evt, gestureState );

		let handled = this.props.onPageScrollMoved && this.props.onPageScrollMoved({
			currentPage: this.currentPage,
			totalPage: this.pageCount,
			width: this.state.width,
			height: this.state.height,
			pageData: this.props.pageDatas[ this.currentPage ]
		}, gestureState, evt);

		if (handled) {
			return;
		}

		let dx = gestureState.moveX - gestureState.previousMoveX;
		this.scrollByOffset(dx);
	}

	onResponderRelease(evt, gestureState, disableSettle: Boolean) {

		this.props.onTouchEnd && this.onTouchEnd(evt, gestureState);

		this.activeGesture = false;
		if (!disableSettle) {
			this.settlePage(gestureState.vx);
		}
	}

	render() {

		let dataSource = this.state.dataSource;
		const { 
			style, 
			onTouchStart, 
			onTouchMove, 
			pageDatas, 
			onTouchEnd, 
			onTouchCancel, 
			scrollEnabled,
			...otherProps 
		} = this.props;

		// if (this.state.width && this.state.height) {

		// 	let list = pageDatas;
		// 	if (!list) {
		// 		list = [];
		// 	}
		// 	dataSource = dataSource.cloneWithRows(list);
		// 	this.pageCount = list.length;
		// }

		let gestureResponder = this.gestureResponder;
		if (!scrollEnabled || this.pageCount <= 0) {

			gestureResponder = {};
		}

		return (
			<View
				style={[style, _style]}
				{ ...gestureResponder }
			>
				<ListView
					showsHorizontalScrollIndicator	= { false }
					showsVerticalScrollIndicator	= { false }
					directionalLockEnabled 			= { true }
					keyboardDismissMode 			= "interactive"
					keyboardShouldPersistTap 		= "always"
					scrollEnabled 					= {false}
					{ ...otherProps }
					style 							= { _style }
					ref 							= { ref => {this.listView = ref;} }
					//contentContainerStyle 		= { _style }
					horizontal 						= {true}
					enableEmptySections 			= {true}
					dataSource 						= {dataSource}
					renderRow 						= {this.renderRow.bind(this)}
					onLayout 						= {this.onLayout.bind(this)}
				/>
			</View>
		);
	}

	renderRow(rowData, sectionID, rowID, highlightRow) {

		const { width, height } = this.state;
		const page = this.props.renderPage(rowData, rowID, { width, height });
		// let newProps = {
		// 	//...page.props,
		// 	ref: page.ref,
		// 	style: [page.props.style, {
		// 		width: width,
		// 		height: height,
		// 		position: 'relative'
		// 	}]
		// };
		//const element = React.createElement(page.type, newProps);
		//const element = React.cloneElement(page, newProps);

		if (this.props.pageMargin > 0 && rowID > 0) {

			//Do not using margin style to implement pageMargin. The ListView seems to calculate a wrong width for children views with margin.
			return (
				<View style={{ 
					width: width + this.props.pageMargin, 
					height: height, 
					position: 'relative',
					alignItems: 'flex-end' 
				}}>
					{ page }
				</View>
			);
		} else {
			
			return (
				<View style={{ 
					width: width, 
					height: height, 
					position: 'relative'
				}}>
					{ page }
				</View>
			);
		}
	}

	onLayout(e) {

		let { width, height } = e.nativeEvent.layout;
		let sizeChanged = this.state.width !== width || this.state.height !== height;
		if (width && height && sizeChanged) {

			//if layout changed, create a new DataSource instance to trigger renderRow
			this.layoutChanged = true;
			this.setState({
				width, 
				height,
				dataSource: this.state.dataSource.cloneWithRows( JSON.parse(JSON.stringify(this.props.pageDatas)) )
			});
		}
	}

	componentDidMount() {

		if (!this.initialPageSettled) {

			this.initialPageSettled = true;

			//A trick to solve bugs on Android. Delay a little
			setTimeout(this.scrollToPage.bind(this, this.props.initialPage, true));
		}
	}

	componentDidUpdate() {

		if (!this.initialPageSettled) {

			this.initialPageSettled = true;
			// if (Platform.OS === 'ios') {

			// 	this.scrollToPage(this.props.initialPage, true);
			// } else {

				//A trick to solve bugs on Android. Delay a little
				setTimeout(this.scrollToPage.bind(this, this.props.initialPage, true), 0);
			//}
		} else if (this.layoutChanged) {

			this.layoutChanged = false;
			if (typeof this.currentPage === 'number') {

				// if (Platform.OS === 'ios') {

				// 	this.scrollToPage(this.currentPage, true);
				// } else {
					//A trick to solve bugs on Android. Delay a little
					setTimeout(this.scrollToPage.bind(this, this.currentPage, true));
				//}
			}
		}
	}

	settlePage(vx: Number) {

		if (vx < -MIN_FLING_VELOCITY) {
			if (this.currentPage < this.pageCount - 1) {
				this.flingToPage(this.currentPage + 1, vx);
			} else {
				this.flingToPage(this.pageCount - 1, vx);
			}
		} else if (vx > MIN_FLING_VELOCITY) {
			if (this.currentPage > 0) {
				this.flingToPage(this.currentPage - 1, vx);
			} else {
				this.flingToPage(0, vx);
			}
		} else {
			let page = this.currentPage;
			let progress = (this.scroller.getCurrX() - this.getScrollOffsetOfPage(this.currentPage)) / this.state.width;
			if (progress > 1 / 3) {
				page += 1;
			} else if (progress < -1 / 3) {
				page -= 1;
			}
			page = this.validPage(page);
			this.scrollToPage(page);
		}
	}

	getScrollOffsetOfPage(page: Number) {

		return page * (this.state.width + this.props.pageMargin);
	}

	flingToPage(page: Number, velocityX: Number) {

		this.onPageScrollStateChanged('settling');

		page = this.validPage(page);
		this.onPageChanged(page);

		velocityX *= -1000; //per sec
		const finalX = this.getScrollOffsetOfPage(page);
		this.scroller.fling(this.scroller.getCurrX(), 0, velocityX, 0, finalX, finalX, 0, 0);

	}

	scrollToPage(page: Number, immediate: Boolean) {

		this.onPageScrollStateChanged('settling');
		page = this.validPage(page);
		this.onPageChanged(page);

		const finalX = this.getScrollOffsetOfPage(page);
		if (immediate) {
			this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 0);
		} else {
			this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 400);
		}
	}

	onPageChanged(page: Number) {

		if (this.currentPage !== page) {
			this.currentPage = page;
			this.props.onPageSelected && this.props.onPageSelected(page);
		}
	}

	onPageScrollStateChanged(state) {
		
		this.props.onPageScrollStateChanged && this.props.onPageScrollStateChanged(state);
	}

	scrollByOffset(dx: Number) {
		this.scroller.startScroll(this.scroller.getCurrX(), 0, -dx, 0, 0);
	}

	validPage(page: Number) {
		
		page = Math.min(this.pageCount - 1, page);
		page = Math.max(0, page);
		return page;
	}

	/**
	 * A helper function to scroll to a specific page in the ViewPager.
	 * @param page
	 * @param immediate If true, the transition between pages will not be animated.
	 */
	setPage(page: Number, immediate: Boolean) {

		//if( this.currentPage !== page ) {

			this.scrollToPage(page, immediate);
		//}
	}

	getScrollOffsetFromCurrentPage() {
		return this.scroller.getCurrX() - this.getScrollOffsetOfPage(this.currentPage);
	}

	getCurrentPage() {

		return this.currentPage;
	}

	getTotalPage() {

		return this.pageCount;
	}
}

const _style = {
	flex: 1
};

export default ViewPager;