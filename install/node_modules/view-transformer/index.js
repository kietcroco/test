'use strict';

import PropTypes from 'prop-types';

/**
import ViewTransformer from 'react-native-view-transformer';
...
render() {
  return (
  	<ViewTransformer>
	  //ANY views
	</ViewTransformer>
  );
}
Now, the wrapped views are transformable!

This component accepts following props:

enableTransform : false to disable transform gestures. Default is true.
enableScale : false to disable scale. Default is true.
enableTranslate : false to disable translateX/Y. Default is true.
enableRotate: false to disable rotate. Default is true.
maxScale : a number. Default is 1.
enableResistance : true to resist over pan. Defaul is false.
maxOverScrollDistance : a number used to determine final scroll position triggered by fling. Default is 20.
onViewTransformed : a callback called when transform changed, receiving current transform object, {scale: xxx, translateX: xxx, translateY: xxx}.
onTransformGestureReleased : a callback called when the transform gesture is released, receiving current transform object, {scale: xxx, translateX: xxx, translateY: xxx, angle: xxx}. Return true to abort further animations like bounce back.
onTransformGestureMoved: a callback called when the transform gesture is moving, receiving current transform object, {scale: xxx, translateX: xxx, translateY: xxx, angle: xxx}. Return true to abort further animations like bounce back.
methods

updateTransform(transform) : immediately transform this view.

Besides transforming an image, this component is helpful in implementing transition animations.

For example, you want to transform a normal size content into a right-bottom floating small window (like the android youtube app). Using this component, you can do as following:

Calculate the normal rect and the final rect. A ViewTransformer.Rect(left, top, right, bottom) object defines the boundary of a view
Use ViewTransformer.getTransform(fromRect, toRect) to get the transform object
Use updateTransform(transform) to make the tranform happen( This is immediate, but you can animate it by calculating the intermediate rects and then transform using your own animation loop)
 */
import React from 'react';
import {
	View,
	Animated,
	Easing,
	NativeModules,
	findNodeHandle
} from 'react-native';

import { createResponder } from 'gesture-responder';
import Scroller from 'scroller';
import { Rect, Transform, transformedRect, availableTranslateSpace, fitCenterRect, alignedRect, getTransform } from './TransformUtils';
import shallowEqual from 'fbjs/lib/shallowEqual';

class ViewTransformer extends React.Component {

	static displayName = "ViewTransformer";
	static Rect = Rect;
	static getTransform = getTransform;

	static propTypes = {
		/**
		 * Use false to disable transform. Default is true.
		 */
		enableTransform: PropTypes.bool,

		/**
		 * Use false to disable scaling. Default is true.
		 */
		enableScale: PropTypes.bool,

		/**
		 * Use false to disable translateX/translateY. Default is true.
		 */
		enableTranslate: PropTypes.bool,

		/**
		 * Use false to disable rotate. Default is true.
		 */
		enableRotate: PropTypes.bool,

		/**
		 * Default is 20
		 */
		maxOverScrollDistance: PropTypes.number,

		maxScale: PropTypes.number,
		contentAspectRatio: PropTypes.number,

		/**
		 * Use true to enable resistance effect on over pulling. Default is false.
		 */
		enableResistance: PropTypes.bool,

		onViewTransformed: PropTypes.func,

		onTransformGestureReleased: PropTypes.func,
		onTransformGestureMoved: PropTypes.func,

		onSingleTap: PropTypes.func,
		onDoubleTap: PropTypes.func,
		onTouchStart: PropTypes.func,
		onTouchMove: PropTypes.func,
		onTouchEnd: PropTypes.func,
		onTouchCancel: PropTypes.func
	};

	static defaultProps = {
		maxOverScrollDistance: 20,
		enableScale: true,
		enableTranslate: true,
		enableTransform: true,
		enableRotate: true,
		maxScale: 2,
		enableResistance: false
	};

	constructor(props) {
		super(props);

		this.state = {
			//transform state
			scale: 1,
			translateX: 0,
			translateY: 0,

			//animation state
			animator: new Animated.Value(0),

			//layout
			width: 0,
			height: 0,
			pageX: 0,
			pageY: 0,
			angle: 0
		};
		this._viewPortRect = new Rect(); //A holder to avoid new too much

		this.cancelAnimation = this.cancelAnimation.bind(this);
		this.contentRect = this.contentRect.bind(this);
		this.transformedContentRect = this.transformedContentRect.bind(this);
		this.animate = this.animate.bind(this);

		this.scroller = new Scroller(true, (dx, dy, scroller) => {

			if (dx === 0 && dy === 0 && scroller.isFinished()) {
				this.animateBounce();
				return;
			}

			this.updateTransform({
				translateX: this.state.translateX + dx / this.state.scale,
				translateY: this.state.translateY + dy / this.state.scale
			});
		});
	}

	componentWillMount() {

		this.gestureResponder = createResponder({
			onStartShouldSetResponder: () => true,
			onMoveShouldSetResponderCapture: () => true,
			onResponderGrant: this.onResponderGrant.bind(this),
			onResponderMove: this.onResponderMove.bind(this),
			onResponderRelease: this.onResponderRelease.bind(this),
			onResponderTerminate: this.onResponderRelease.bind(this),
			onResponderReject: this.onResponderReject.bind(this),
			onResponderTerminationRequest: () => false, //Do not allow parent view to intercept gesture
			onResponderSingleTapConfirmed: this.onResponderSingleTapConfirmed.bind(this),
			onResponderDoubleTapConfirmed: this.onResponderDoubleTapConfirmed.bind(this)
		});
	}
	
	shouldComponentUpdate( nextProps, nextState ) {

		return (
			this.state.scale !== nextState.scale ||
			this.state.angle !== nextState.angle ||
			this.state.translateX !== nextState.translateX ||
			this.state.translateY !== nextState.translateY ||
			this.state.width !== nextState.width ||
			this.state.height !== nextState.height ||
			this.state.pageX !== nextState.pageX ||
			this.state.pageY !== nextState.pageY ||
			!shallowEqual( this.props, nextProps )
		);
	}

	componentDidUpdate(prevProps, prevState) {

		this.props.onViewTransformed && this.props.onViewTransformed({
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		});
	}

	componentWillUnmount() {
		
		this.cancelAnimation();
	}

	render() {

		let gestureResponder = this.gestureResponder;
		if (!this.props.enableTransform) {

			gestureResponder = {};
		}

		const { onTouchStart, onTouchMove, onTouchEnd, onTouchCancel, ...otherProps } = this.props;

		return (
			<View
				{ ...otherProps }
				{ ...gestureResponder }
				ref 			= { ref => { this.wrapperView = ref; } }
				onLayout 		= { this.onLayout.bind(this) }>
				<View
					style={{
						flex: 1,
						transform: [
							{ scale: this.state.scale },
							{ translateX: this.state.translateX },
							{ translateY: this.state.translateY },
							{ rotate: `${ this.state.angle }deg`}
						]
					}}>
					{ this.props.children }
				</View>
			</View>
		);
	}

	onLayout(e) {

		const { width, height } = e.nativeEvent.layout;
		if (width !== this.state.width || height !== this.state.height) {
			this.setState({ width, height });
		}
		this.measureLayout();

		this.props.onLayout && this.props.onLayout(e);
	}

	viewPortRect() {

		this._viewPortRect.set({
			left: 0,
			top: 0, 
			right: this.state.width, 
			bottom: this.state.height,
			angle: 0
		});
		return this._viewPortRect;
	}

	contentRect() {

		let rect = this.viewPortRect().copy();
		if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {
			rect = fitCenterRect(this.props.contentAspectRatio, rect);
		}
		return rect;
	}

	transformedContentRect() {

		let rect = transformedRect(this.viewPortRect(), this.currentTransform());
		if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {

			rect = fitCenterRect(this.props.contentAspectRatio, rect);
		}
		return rect;
	}

	currentTransform() {

		return new Transform({
			scale: this.state.scale, 
			translateX: this.state.translateX, 
			translateY: this.state.translateY,
			angle: this.state.angle
		});
	}

	measureLayout() {

		let handle = findNodeHandle( this.wrapperView );

		NativeModules.UIManager.measure(handle, ((x, y, width, height, pageX, pageY) => {
			if (typeof pageX === 'number' && typeof pageY === 'number') { //avoid undefined values on Android devices
				if (this.state.pageX !== pageX || this.state.pageY !== pageY) {
					this.setState({
						pageX: pageX,
						pageY: pageY
					});
				}
			}

		}).bind(this));
	}

	onResponderGrant(evt, gestureState) {

		this.props.onTouchStart && this.props.onTouchStart(evt, gestureState, {
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		});
		//this.setState({ responderGranted: true });
		this.measureLayout();
	}

	onResponderMove(evt, gestureState) {

		this.cancelAnimation();
		this.props.onTouchMove && this.props.onTouchMove( evt, gestureState, {
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		} );

		let handled = this.props.onTransformGestureMoved && this.props.onTransformGestureMoved({
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		}, gestureState, evt);

		if (handled) {
			return;
		}

		let dx = gestureState.moveX - gestureState.previousMoveX;
		let dy = gestureState.moveY - gestureState.previousMoveY;
		let angle = this.state.angle;

		if (this.props.enableResistance) {
			let d = this.applyResistance(dx, dy);
			dx = d.dx;
			dy = d.dy;
		}

		if (!this.props.enableTranslate) {
			dx = dy = 0;
		}

		if(this.props.enableRotate && gestureState.angle && gestureState.previousAngle) {

			angle = this.state.angle + (gestureState.angle - gestureState.previousAngle);
		}

		if (angle < 0) {

			angle += 360;
		}
		if( angle >= 360 ) {

			angle -= 360;
		}

		let transform = { angle };
		if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {

			let scaleBy = gestureState.pinch / gestureState.previousPinch;
			let pivotX = gestureState.moveX - this.state.pageX;
			let pivotY = gestureState.moveY - this.state.pageY;

			let rect = transformedRect(transformedRect(this.contentRect(), this.currentTransform()), new Transform({
				scale: scaleBy, 
				translateX: dx, 
				translateY: dy,
				pivot: {
					x: pivotX,
					y: pivotY
				},
				angle
			}));
			transform = getTransform(this.contentRect(), rect);
		} else {

			if (Math.abs(dx) > 2 * Math.abs(dy)) {
				dy = 0;
			} else if (Math.abs(dy) > 2 * Math.abs(dx)) {
				dx = 0;
			}

			transform.translateX = this.state.translateX + dx / this.state.scale;
			transform.translateY = this.state.translateY + dy / this.state.scale;
		}
		
		this.updateTransform(transform);
		return true;
	}

	onResponderRelease(evt, gestureState) {

		this.props.onTouchEnd && this.props.onTouchEnd( evt, gestureState, {
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		} );

		let handled = this.props.onTransformGestureReleased && this.props.onTransformGestureReleased({
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		}, gestureState, evt);

		if (handled) {
			return;
		}

		if (gestureState.doubleTapUp) {
			if (!this.props.enableScale) {
				this.animateBounce();
				return;
			}
			let pivotX = 0, pivotY = 0;
			if (gestureState.dx || gestureState.dy) {
				pivotX = gestureState.moveX - this.state.pageX;
				pivotY = gestureState.moveY - this.state.pageY;
			} else {
				pivotX = gestureState.x0 - this.state.pageX;
				pivotY = gestureState.y0 - this.state.pageY;
			}

			this.performDoubleTapUp(pivotX, pivotY);
		} else {
			if (this.props.enableTranslate) {
				this.performFling(gestureState.vx, gestureState.vy);
			} else {
				this.animateBounce();
			}
		}
	}

	onResponderReject(evt, gestureState) {

		this.props.onTouchCancel && this.props.onTouchCancel(evt, gestureState, {
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		});
	}

	onResponderSingleTapConfirmed(evt, gestureState) {

		this.props.onSingleTap && this.props.onSingleTap(evt, gestureState, {
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		});
	}

	onResponderDoubleTapConfirmed(evt, gestureState) {

		this.props.onDoubleTap && this.props.onDoubleTap(evt, gestureState, {
			scale: this.state.scale,
			translateX: this.state.translateX,
			translateY: this.state.translateY,
			angle: this.state.angle
		});
	}

	performFling(vx, vy) {

		let startX = 0;
		let startY = 0;
		let maxX, minX, maxY, minY;
		let availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());
		if (vx > 0) {
			minX = 0;
			if (availablePanDistance.left > 0) {
				maxX = availablePanDistance.left + this.props.maxOverScrollDistance;
			} else {
				maxX = 0;
			}
		} else {
			maxX = 0;
			if (availablePanDistance.right > 0) {
				minX = -availablePanDistance.right - this.props.maxOverScrollDistance;
			} else {
				minX = 0;
			}
		}
		if (vy > 0) {
			minY = 0;
			if (availablePanDistance.top > 0) {
				maxY = availablePanDistance.top + this.props.maxOverScrollDistance;
			} else {
				maxY = 0;
			}
		} else {
			maxY = 0;
			if (availablePanDistance.bottom > 0) {
				minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;
			} else {
				minY = 0;
			}
		}

		vx *= 1000; //per second
		vy *= 1000;
		if (Math.abs(vx) > 2 * Math.abs(vy)) {
			vy = 0;
		} else if (Math.abs(vy) > 2 * Math.abs(vx)) {
			vx = 0;
		}

		this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);
	}

	performDoubleTapUp(pivotX, pivotY) {

		//console.log('performDoubleTapUp...pivot=' + pivotX + ', ' + pivotY);
		let curScale = this.state.scale;
		let angle = this.state.angle;
		let scaleBy;
		if (curScale > (1 + this.props.maxScale) / 2) {
			scaleBy = 1 / curScale;
		} else {
			scaleBy = this.props.maxScale / curScale;
		}

		let rect = transformedRect(this.transformedContentRect(), new Transform({
			scale: scaleBy, 
			translateX: 0, 
			translateY: 0,
			pivot: {
				x: pivotX,
				y: pivotY
			},
			angle 
		}));

		rect = transformedRect(rect, new Transform({
			scale: 1, 
			translateX: this.viewPortRect().centerX() - pivotX, 
			translateY: this.viewPortRect().centerY() - pivotY,
			angle: 0
		}));
		rect = alignedRect(rect, this.viewPortRect());

		this.animate(rect);
	}

	applyResistance(dx, dy) {

		let availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());

		if ((dx > 0 && availablePanDistance.left < 0)
			||
			(dx < 0 && availablePanDistance.right < 0)) {
			dx /= 3;
		}
		if ((dy > 0 && availablePanDistance.top < 0)
			||
			(dy < 0 && availablePanDistance.bottom < 0)) {
			dy /= 3;
		}
		return {
			dx, dy
		}
	}

	cancelAnimation() {

		this.state.animator.stopAnimation();
	}

	animate(targetRect, durationInMillis) {

		let duration = 200;
		if (durationInMillis) {
			duration = durationInMillis;
		}

		let fromRect = this.transformedContentRect();
		if (fromRect.equals(targetRect)) {
			//console.log('animate...equal rect, skip animation');
			return;
		}

		this.state.animator.removeAllListeners();
		this.state.animator.setValue(0);
		this.state.animator.addListener((state) => {
			let progress = state.value;

			let left = fromRect.left + (targetRect.left - fromRect.left) * progress;
			let right = fromRect.right + (targetRect.right - fromRect.right) * progress;
			let top = fromRect.top + (targetRect.top - fromRect.top) * progress;
			let bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;
			let angle = fromRect.angle + (targetRect.angle - fromRect.angle) * progress;

			let transform = getTransform(this.contentRect(), new Rect({
				left, 
				top, 
				right, 
				bottom,
				angle
			}));
			this.updateTransform(transform);
		});

		Animated.timing(this.state.animator, {
			toValue: 1,
			duration: duration,
			easing: Easing.inOut(Easing.ease)
		}).start();
	}

	animateBounce() {

		let curScale = this.state.scale;
		let angle = this.state.angle;
		let minScale = 1;
		let maxScale = this.props.maxScale;
		let scaleBy = 1;
		if (curScale > maxScale) {
			scaleBy = maxScale / curScale;
		} else if (curScale < minScale) {
			scaleBy = minScale / curScale;
		}

		let rect = transformedRect(this.transformedContentRect(), new Transform({
			scale: scaleBy,
			translateX: 0,
			translateY: 0,
			pivot: {
				x: this.viewPortRect().centerX(),
				y: this.viewPortRect().centerY()
			},
			angle
		}));
		rect = alignedRect(rect, this.viewPortRect());
		this.animate(rect);
	}

	// Above are private functions. Do not use them if you don't known what you are doing.
	// ***********************************************************************************
	// Below are public functions. Feel free to use them.
	updateTransform(transform) {

		this.setState(transform);
	}

	forceUpdateTransform(transform) {

		this.setState(transform);
	}

	getAvailableTranslateSpace() {

		return availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());
	}
}

export default ViewTransformer;