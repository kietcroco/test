"use strict";
import PropTypes from 'prop-types';
import React from 'react';
import { View, Image, ScrollView } from 'react-native';
import Transformer from 'view-transformer';
import Title from './components/Title';
import Navigation from './components/Navigation';
import ViewPager from 'view-pager';
import { createResponder } from 'gesture-responder';
import shallowEqual from 'fbjs/lib/shallowEqual';

class Gallery extends React.Component {

	static displayName = "Gallery";

	static propTypes = {
		navigation: PropTypes.bool, // cho phép hiển thị thanh điều hướng
		buttonStyle: PropTypes.object, // css cho các button
		iconStyle: PropTypes.object, // css cho các icon
		titleStyle: PropTypes.object, // css cho tiêu đề
		pagination: PropTypes.bool, // cho phép hiển thị số trang
		paginationStyle: PropTypes.object, // css cho số trang
		imageStyle: PropTypes.object, // css cho image
		closeHandle: PropTypes.func, // nút close
		navigationStyle: PropTypes.object, // css cho thanh điều hướng
		headStyle: PropTypes.object, // css cho header
		source: PropTypes.arrayOf(PropTypes.shape({
			caption: PropTypes.string,
			source: PropTypes.oneOfType([
				PropTypes.number,
				PropTypes.object,
				PropTypes.string
			]).isRequired
		})).isRequired,
		hitSlop: PropTypes.object,
		autoplay: PropTypes.bool,
		autoplayDelay: PropTypes.number,
		autoplayInterval: PropTypes.number,
		onNext: PropTypes.func,
		onPrev: PropTypes.func,
		onPlay: PropTypes.func,
		onPause: PropTypes.func,
		initItem: PropTypes.number,
		onItemSelected: PropTypes.func,
		onLongPress: PropTypes.func,
		onSingleTap: PropTypes.func,
		onDoubleTap: PropTypes.func
	};

	static defaultProps = {
		initItem: 0,
		navigation: true,
		pagination: true,
		autoplay: false,
		autoplayDelay: 500,
		autoplayInterval: 2500,
		source: []
	};

	constructor(props) {
		super(props);

		this.state = {
			currentIndex: props.initItem,
			playing: false
		};

		this.transformerRefs = new Map();
		this.activeResponder = undefined;
		this.firstMove = true;
		this.pageCount = props.source.length;
		this.gestureResponder = undefined;

		this.renderPage = this.renderPage.bind(this);
		this.onPageSelected = this.onPageSelected.bind(this);
		this.onPageScrollStateChanged = this.onPageScrollStateChanged.bind(this);
		this.onPageScroll = this.onPageScroll.bind(this);
		this.onTransformGestureMoved = this.onTransformGestureMoved.bind(this);

		this._autoplayInterval = undefined;
		this._autoplayTimeOut = undefined;
	}

	componentWillReceiveProps(nextProps) {

		if( this.props.source != nextProps.source ) {
			
			this.pageCount = nextProps.source.length;
		}
		if( nextProps.autoplay && this.props.autoplayInterval !== nextProps.autoplayInterval ) {

			this.pause();
			this.play();
		}
		if( this.props.autoplay !== nextProps.autoplay ) {

			if( nextProps.autoplay ) {

				this.play();
			} else {

				this.pause();
			}
		}
	}

	get currentIndex() {

		return this.state.currentIndex;
	}

	setItem( index: Number = 0 ) {

		this.viewPager.setPage( index );
	}

	previous() {

		let prevPage = this.state.currentIndex - 1;
		if( this.viewPager.validPage( prevPage ) > prevPage ) {

			prevPage = this.viewPager.getTotalPage();
		}

		this.viewPager.setPage( prevPage, true );
	}
	next() {
		let nextPage = this.state.currentIndex + 1;
		if( this.viewPager.validPage( nextPage ) < nextPage ) {
			nextPage = 0;
		}

		this.viewPager.setPage( nextPage, true );
	}
	
	play() {

		if( !this.props.source.length ) {
			return;
		}

		this._setTime();
		!this.state.playing && this.setState({
			playing: true
		});

		//this.props.onPlay && this.props.onPlay( this.state.currentIndex );
	}

	pause() {

		this._clearTime();
		this.state.playing && this.setState({
			playing: false
		});

		//this.props.onPause && this.props.onPause( this.state.currentIndex );
	}

	onPageSelected(page) {

		let currentIndex = this.state.currentIndex;

		this._clearTime();
		this.state.playing && this._setTime();

		this.setState({
			currentIndex: page
		});

		if( currentIndex > page || ( currentIndex === 0 && page === this.pageCount ) ) {

			this.props.onPrev && this.props.onPrev( prevPage );
		} else if( currentIndex < page || ( currentIndex === this.pageCount && page === 0 ) ) {

			this.props.onNext && this.props.onNext( nextPage );
		}

		this.props.onItemSelected && this.props.onItemSelected(page);
	}

	_clearTime() {
		if( this._autoplayTimeOut ) {
			clearTimeout( this._autoplayTimeOut );
			this._autoplayTimeOut = undefined;
		}
		if( this._autoplayInterval ) {
			clearInterval( this._autoplayInterval );
			this._autoplayInterval = undefined;
		}
	}

	_setTime() {
		if( this._autoplayInterval ) {
			clearInterval( this._autoplayInterval );
			this._autoplayInterval = undefined;
		}
		this._autoplayInterval = setInterval( () => this.next(), this.props.autoplayInterval );
	}

	shouldComponentUpdate( nextProps, nextState ) {

		return (
			this.state.currentIndex !== nextState.currentIndex ||
			this.state.playing !== nextState.playing ||
			!shallowEqual( this.props, nextProps )
		);
	}

	componentWillMount() {

		this.gestureResponder = createResponder({
			onStartShouldSetResponderCapture: () => true,
			onStartShouldSetResponder: () => true,
			onResponderGrant: this.onResponderGrant.bind(this),
			onResponderMove: this.onResponderMove.bind(this),
			onResponderRelease: this.onResponderRelease.bind(this),
			onResponderTerminate: this.onResponderRelease.bind(this),
			onResponderTerminationRequest: () => false, // Do not allow parent view to intercept gesture
			onResponderSingleTapConfirmed: () => ( this.props.onSingleTap && this.props.onSingleTap(this.state.currentIndex) ),
			onResponderDoubleTapConfirmed: () => ( this.props.onDoubleTap && this.props.onDoubleTap(this.state.currentIndex) )
		});

		this.viewPagerResponder = {
            onStart: (evt, gestureState) => {
                this.viewPager.onResponderGrant(evt, gestureState);
            },
            onMove: (evt, gestureState) => {
                this.viewPager.onResponderMove(evt, gestureState);
            },
            onEnd: (evt, gestureState, disableSettle) => {
                this.viewPager.onResponderRelease(evt, gestureState, disableSettle);
            }
        };

        this.imageResponder = {
            onStart: (evt, gestureState) => {

                this.getCurrentImageTransformer().onResponderGrant(evt, gestureState);

                if (this.props.onLongPress) {
                    this._longPressTimeout = setTimeout(() => {
                        this.props.onLongPress(gestureState);
                    }, 600);
                }
            },
            onMove: (evt, gestureState) => {
				
                this.getCurrentImageTransformer().onResponderMove(evt, gestureState);
                clearTimeout(this._longPressTimeout);
            },
            onEnd: (evt, gestureState) => {
                this.getCurrentImageTransformer().onResponderRelease(evt, gestureState);
                clearTimeout(this._longPressTimeout);
            }
        };
	}

	onResponderGrant(evt, gestureState) {

		this.activeImageResponder(evt, gestureState);
	}

	onResponderMove(evt, gestureState) {

		if (this.firstMove) {
			this.firstMove = false;

			if (this.shouldScrollViewPager(evt, gestureState)) {

				this.activeViewPagerResponder(evt, gestureState);
			}
			this.props.onGalleryStateChanged && this.props.onGalleryStateChanged(false);
		}
		if (this.activeResponder === this.viewPagerResponder) {

			const dx = gestureState.moveX - gestureState.previousMoveX;
			const offset = this.viewPager.getScrollOffsetFromCurrentPage();

			if (dx > 0 && offset > 0 && !this.shouldScrollViewPager(evt, gestureState)) {

				if (dx > offset) { // active image responder
					this.viewPager.scrollByOffset(offset);
					gestureState.moveX -= offset;
					this.activeImageResponder(evt, gestureState);
				}
			} else if (dx < 0 && offset < 0 && !this.shouldScrollViewPager(evt, gestureState)) {

				if (dx < offset) { // active image responder

					this.viewPager.scrollByOffset(offset);
					gestureState.moveX -= offset;
					this.activeImageResponder(evt, gestureState);
				}
			}
		}
		this.activeResponder.onMove(evt, gestureState);
	}

	onPageScroll(e) {

		this.props.onPageScroll && this.props.onPageScroll(e);
	}

	onPageScrollStateChanged(state) {

		if (state === 'idle') {
			this.resetHistoryImageTransform();
		}
		this.props.onPageScrollStateChanged && this.props.onPageScrollStateChanged(state);
	}

	resetHistoryImageTransform() {

		let transformer = this.getImageTransformer(this.state.currentIndex + 1);

		if (transformer) {

			transformer.forceUpdateTransform({ scale: 1, translateX: 0, translateY: 0, angle: 0 });
		}

		transformer = this.getImageTransformer(this.state.currentIndex - 1);
		if (transformer) {

			transformer.forceUpdateTransform({ scale: 1, translateX: 0, translateY: 0, angle: 0 });
		}
	}

	onResponderRelease(evt, gestureState) {

		if (this.activeResponder) {

			if (this.activeResponder === this.viewPagerResponder &&
				!this.shouldScrollViewPager(evt, gestureState) &&
				Math.abs(gestureState.vx) > 0.5
			) {
				this.activeResponder.onEnd(evt, gestureState, true);
				this.viewPager.flingToPage(this.state.currentIndex, gestureState.vx);
			} else {
				this.activeResponder.onEnd(evt, gestureState);
			}
			this.activeResponder = null;
		}
		this.firstMove = true;
		this.props.onGalleryStateChanged && this.props.onGalleryStateChanged(true);
	}

	shouldScrollViewPager(evt, gestureState) {

		if (gestureState.numberActiveTouches > 1) {

			return false;
		}
		const viewTransformer = this.getCurrentImageTransformer();
		const space = viewTransformer.getAvailableTranslateSpace();
		const dx = gestureState.moveX - gestureState.previousMoveX;

		if (dx > 0 && space.left <= 0 && this.state.currentIndex > 0) {
			return true;
		}
		if (dx < 0 && space.right <= 0 && this.state.currentIndex < this.pageCount - 1) {
			return true;
		}
		return false;
	}

	activeViewPagerResponder(evt, gestureState) {

		if (this.activeResponder !== this.viewPagerResponder) {

			if (this.activeResponder === this.imageResponder) {

				this.imageResponder.onEnd(evt, gestureState);
			}
			this.activeResponder = this.viewPagerResponder;
			this.viewPagerResponder.onStart(evt, gestureState);
		}
	}

	activeImageResponder(evt, gestureState) {

		if (this.activeResponder !== this.imageResponder) {

			if (this.activeResponder === this.viewPagerResponder) {

				this.viewPagerResponder.onEnd(evt, gestureState, true); // pass true to disable ViewPager settle
			}
			this.activeResponder = this.imageResponder;
			this.imageResponder.onStart(evt, gestureState);
		}
	}

	shouldScrollViewPager(evt, gestureState) {

		if (gestureState.numberActiveTouches > 1) {

			return false;
		}
		const viewTransformer = this.getCurrentImageTransformer();
		const space = viewTransformer.getAvailableTranslateSpace();
		const dx = gestureState.moveX - gestureState.previousMoveX;

		if (dx > 0 && space.left <= 0 && this.state.currentIndex > 0) {
			return true;
		}
		if (dx < 0 && space.right <= 0 && this.state.currentIndex < this.pageCount - 1) {

			return true;
		}
		return false;
	}

	getCurrentImageTransformer() {

		return this.getImageTransformer(this.state.currentIndex);
	}

	getImageTransformer(page) {

		if (page >= 0 && page < this.pageCount) {

			let ref = this.transformerRefs.get(`transformer-${page}`);
			if (ref) {
				return ref;
			}
		}
	}

	onTransformGestureMoved({scale}) {

		if( this.state.playing && scale > 1.05 ) {

			this.pause();
			this.props.onPause && this.props.onPause( this.state.currentIndex );
		}
	}

	renderPage(pageData, pageId, layout) {

		const { onError, onLoad, blurRadius, onLoadEnd, onLoadStart } = this.props;

		const imageStyle = this.props.imageStyle ? {
			..._styles.image,
			...this.props.imageStyle
		} : _styles.image;

		let source = pageData.source;
		if( typeof source === "string" ) {

			source = {uri: source};
		}

		return (
			<Transformer
				style 				= { _styles.transformer }
				key 				= {`transformer-${pageId}`}
				enableTransform 	= {false}
				ref 				= {ref => { this.transformerRefs.set(`transformer-${pageId}`, ref); }}
				onTransformGestureMoved={ this.onTransformGestureMoved }
			>
				<Image
					source 			= { source }
					style 			= { imageStyle }
					onError 		= { onError }
					onLoad 			= { onLoad }
					blurRadius 		= { blurRadius }
					onLoadEnd 		= { onLoadEnd }
					onLoadStart 	= { onLoadStart }
				/>
			</Transformer>
		);
	}

	render() {

		const {
			style,
			children,
			navigation,
			navigationStyle,
			buttonStyle,
			titleStyle,
			iconStyle,
			paginationStyle,
			pagination,
			headStyle,
			closeHandle,
			source,
			hitSlop,
			autoplay,
			initItem,
			onPlay,
			onPause
		} = this.props;

		let gestureResponder = this.gestureResponder;

		this.pageCount = source.length;

		if (this.pageCount <= 0) {
			gestureResponder = {};
		}

		return (
			<View style={[_styles.wrapper, style]}>
				<View style={_styles.wrapper} { ...gestureResponder }>
					<ViewPager
						style 						= {_styles.wrapper}
						renderPage 					= {this.renderPage}
						pageDatas 					= { source }
						ref 						= {ref => { this.viewPager = ref; }}
						scrollEnabled 				= {false}
						onPageSelected 				= {this.onPageSelected}
						onPageScrollStateChanged 	= {this.onPageScrollStateChanged}
						onPageScroll 				= {this.onPageScroll}
						initialPage 				= { initItem }
					/>
				</View>
				{
					<Title
						pagination 				= {pagination}
						currentPage 			= {source.length ? this.state.currentIndex + 1 : source.length}
						totalPage 				= {source.length}
						onClose 				= {closeHandle}
						titleStyle 				= {titleStyle}
						paginationStyle 		= {paginationStyle}
						buttonStyle 			= {buttonStyle}
						iconStyle 				= {iconStyle}
						style 					= {headStyle}
						hitSlop 				= {hitSlop}
					>{source[this.state.currentIndex] ? source[this.state.currentIndex].caption : ""}</Title>
				}
				{
					navigation && <Navigation
						isPlay 					= { this.state.playing }
						onPlay 					= { () => {

							if( source.length > 1 ) {

								this.play();
								onPlay && onPlay( this.state.currentIndex );
							}
						} }
						onPrev 					= { this.previous.bind(this) }
						onNext 					= { this.next.bind(this) }
						onPause 				= { () => {

							this.pause();
							onPause && onPause( this.state.currentIndex );
						} }
						buttonStyle 			= { buttonStyle }
						iconStyle 				= { iconStyle }
						style 					= { navigationStyle }
						hitSlop 				= { hitSlop }
					/>
				}
			</View>
		)
	}

	componentDidMount() {

		if( !this._autoplayTimeOut && this.props.autoplay && this.props.source.length > 1 ) {

			this.setState({
				playing: true
			});
			this._autoplayTimeOut = setTimeout( () => this.play(), this.props.autoplayDelay );
		}
	}

	componentWillUnmount() {

		this._clearTime();
	}
}

const _styles = {
	wrapper: {
		flex: 1,
		position: "relative",
		backgroundColor: "black"
	},
	transformer: {
		flex: 1,
		position: "relative"
	},
	image: {
		flex: 1,
		width: "100%",
		resizeMode: "contain"
	}
};

export default Gallery;